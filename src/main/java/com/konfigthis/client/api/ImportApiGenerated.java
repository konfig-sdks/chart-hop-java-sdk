/*
 * ChartHop API
 * REST API for ChartHop
 *
 * The version of the OpenAPI document: V1.0.0
 * Contact: support@charthop.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import com.konfigthis.client.model.FileUploadNewFileRequest;
import com.konfigthis.client.model.ImportCsvDataWithColumnMatchRequest;
import java.time.LocalDate;
import com.konfigthis.client.model.Process;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class ImportApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ImportApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public ImportApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call csvDataCall(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fileUploadNewFileRequest;

        // create path and map variables
        String localVarPath = "/v1/org/{orgId}/import/csv/data"
            .replace("{" + "orgId" + "}", localVarApiClient.escapeString(orgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scenarioId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scenarioId", scenarioId));
        }

        if (skipErrors != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipErrors", skipErrors));
        }

        if (upsert != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("upsert", upsert));
        }

        if (createGroups != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("createGroups", createGroups));
        }

        if (disableSyncHireDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("disableSyncHireDate", disableSyncHireDate));
        }

        if (updateTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updateTypes", updateTypes));
        }

        if (notifyUserIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyUserIds", notifyUserIds));
        }

        if (notifyAppName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyAppName", notifyAppName));
        }

        if (defaultChangeDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("defaultChangeDate", defaultChangeDate));
        }

        if (disableOverwritePerson != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("disableOverwritePerson", disableOverwritePerson));
        }

        if (importDryRun != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importDryRun", importDryRun));
        }

        if (importAfterDryRun != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importAfterDryRun", importAfterDryRun));
        }

        if (parentProcessId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentProcessId", parentProcessId));
        }

        if (importSource != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importSource", importSource));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call csvDataValidateBeforeCall(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orgId' is set
        if (orgId == null) {
            throw new ApiException("Missing the required parameter 'orgId' when calling csvData(Async)");
        }

        return csvDataCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, fileUploadNewFileRequest, _callback);

    }


    private ApiResponse<Process> csvDataWithHttpInfo(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, FileUploadNewFileRequest fileUploadNewFileRequest) throws ApiException {
        okhttp3.Call localVarCall = csvDataValidateBeforeCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, fileUploadNewFileRequest, null);
        Type localVarReturnType = new TypeToken<Process>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call csvDataAsync(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback<Process> _callback) throws ApiException {

        okhttp3.Call localVarCall = csvDataValidateBeforeCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, fileUploadNewFileRequest, _callback);
        Type localVarReturnType = new TypeToken<Process>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CsvDataRequestBuilder {
        private final String orgId;
        private File _file;
        private String scenarioId;
        private Boolean skipErrors;
        private Boolean upsert;
        private Boolean createGroups;
        private Boolean disableSyncHireDate;
        private String updateTypes;
        private String notifyUserIds;
        private String notifyAppName;
        private LocalDate defaultChangeDate;
        private Boolean disableOverwritePerson;
        private Boolean importDryRun;
        private Boolean importAfterDryRun;
        private String parentProcessId;
        private String importSource;

        private CsvDataRequestBuilder(String orgId) {
            this.orgId = orgId;
        }

        /**
         * Set _file
         * @param _file  (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder _file(File _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set scenarioId
         * @param scenarioId scenario id to import into (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder scenarioId(String scenarioId) {
            this.scenarioId = scenarioId;
            return this;
        }
        
        /**
         * Set skipErrors
         * @param skipErrors whether to skip erroneous rows, or reject the entire upload if any are invalid (default) (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder skipErrors(Boolean skipErrors) {
            this.skipErrors = skipErrors;
            return this;
        }
        
        /**
         * Set upsert
         * @param upsert whether to create persons/jobs that are not matched (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder upsert(Boolean upsert) {
            this.upsert = upsert;
            return this;
        }
        
        /**
         * Set createGroups
         * @param createGroups whether to create groups that are not matched (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder createGroups(Boolean createGroups) {
            this.createGroups = createGroups;
            return this;
        }
        
        /**
         * Set disableSyncHireDate
         * @param disableSyncHireDate whether to disable adjusting dates of hires in cases where the start dates differ (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder disableSyncHireDate(Boolean disableSyncHireDate) {
            this.disableSyncHireDate = disableSyncHireDate;
            return this;
        }
        
        /**
         * Set updateTypes
         * @param updateTypes types of updates to apply (default all: title,comp,group,relationship,data,other) (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder updateTypes(String updateTypes) {
            this.updateTypes = updateTypes;
            return this;
        }
        
        /**
         * Set notifyUserIds
         * @param notifyUserIds comma-separated list of user ids who should be notified when the import is complete (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder notifyUserIds(String notifyUserIds) {
            this.notifyUserIds = notifyUserIds;
            return this;
        }
        
        /**
         * Set notifyAppName
         * @param notifyAppName name of the app that should be listed in the notify (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder notifyAppName(String notifyAppName) {
            this.notifyAppName = notifyAppName;
            return this;
        }
        
        /**
         * Set defaultChangeDate
         * @param defaultChangeDate date of the changes - if not presented on the csv file (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder defaultChangeDate(LocalDate defaultChangeDate) {
            this.defaultChangeDate = defaultChangeDate;
            return this;
        }
        
        /**
         * Set disableOverwritePerson
         * @param disableOverwritePerson disable overwriting changes to persons&#39; data -- only update data if the person field is null (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder disableOverwritePerson(Boolean disableOverwritePerson) {
            this.disableOverwritePerson = disableOverwritePerson;
            return this;
        }
        
        /**
         * Set importDryRun
         * @param importDryRun import dry run (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder importDryRun(Boolean importDryRun) {
            this.importDryRun = importDryRun;
            return this;
        }
        
        /**
         * Set importAfterDryRun
         * @param importAfterDryRun whether to automatically import if dry run succeeds (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder importAfterDryRun(Boolean importAfterDryRun) {
            this.importAfterDryRun = importAfterDryRun;
            return this;
        }
        
        /**
         * Set parentProcessId
         * @param parentProcessId process id of parent process (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder parentProcessId(String parentProcessId) {
            this.parentProcessId = parentProcessId;
            return this;
        }
        
        /**
         * Set importSource
         * @param importSource self identified source caller into this method (optional)
         * @return CsvDataRequestBuilder
         */
        public CsvDataRequestBuilder importSource(String importSource) {
            this.importSource = importSource;
            return this;
        }
        
        /**
         * Build call for csvData
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return csvDataCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, fileUploadNewFileRequest, _callback);
        }

        private FileUploadNewFileRequest buildBodyParams() {
            FileUploadNewFileRequest fileUploadNewFileRequest = new FileUploadNewFileRequest();
            fileUploadNewFileRequest._file(this._file);
            return fileUploadNewFileRequest;
        }

        /**
         * Execute csvData request
         * @return Process
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public Process execute() throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            ApiResponse<Process> localVarResp = csvDataWithHttpInfo(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, fileUploadNewFileRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute csvData request with HTTP info returned
         * @return ApiResponse&lt;Process&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Process> executeWithHttpInfo() throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return csvDataWithHttpInfo(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, fileUploadNewFileRequest);
        }

        /**
         * Execute csvData request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Process> _callback) throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return csvDataAsync(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, fileUploadNewFileRequest, _callback);
        }
    }

    /**
     * Import data from CSV file
     * 
     * @param orgId Org identifier (either id or slug) (required)
     * @return CsvDataRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
     </table>
     */
    public CsvDataRequestBuilder csvData(String orgId) throws IllegalArgumentException {
        if (orgId == null) throw new IllegalArgumentException("\"orgId\" is required but got null");
            

        return new CsvDataRequestBuilder(orgId);
    }
    private okhttp3.Call csvDataColumnMatchCall(String orgId, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fileUploadNewFileRequest;

        // create path and map variables
        String localVarPath = "/v1/org/{orgId}/import/csv/initialColumnMatch"
            .replace("{" + "orgId" + "}", localVarApiClient.escapeString(orgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call csvDataColumnMatchValidateBeforeCall(String orgId, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orgId' is set
        if (orgId == null) {
            throw new ApiException("Missing the required parameter 'orgId' when calling csvDataColumnMatch(Async)");
        }

        return csvDataColumnMatchCall(orgId, fileUploadNewFileRequest, _callback);

    }


    private ApiResponse<Void> csvDataColumnMatchWithHttpInfo(String orgId, FileUploadNewFileRequest fileUploadNewFileRequest) throws ApiException {
        okhttp3.Call localVarCall = csvDataColumnMatchValidateBeforeCall(orgId, fileUploadNewFileRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call csvDataColumnMatchAsync(String orgId, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = csvDataColumnMatchValidateBeforeCall(orgId, fileUploadNewFileRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class CsvDataColumnMatchRequestBuilder {
        private final String orgId;
        private File _file;

        private CsvDataColumnMatchRequestBuilder(String orgId) {
            this.orgId = orgId;
        }

        /**
         * Set _file
         * @param _file  (optional)
         * @return CsvDataColumnMatchRequestBuilder
         */
        public CsvDataColumnMatchRequestBuilder _file(File _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Build call for csvDataColumnMatch
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return csvDataColumnMatchCall(orgId, fileUploadNewFileRequest, _callback);
        }

        private FileUploadNewFileRequest buildBodyParams() {
            FileUploadNewFileRequest fileUploadNewFileRequest = new FileUploadNewFileRequest();
            fileUploadNewFileRequest._file(this._file);
            return fileUploadNewFileRequest;
        }

        /**
         * Execute csvDataColumnMatch request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            csvDataColumnMatchWithHttpInfo(orgId, fileUploadNewFileRequest);
        }

        /**
         * Execute csvDataColumnMatch request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return csvDataColumnMatchWithHttpInfo(orgId, fileUploadNewFileRequest);
        }

        /**
         * Execute csvDataColumnMatch request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return csvDataColumnMatchAsync(orgId, fileUploadNewFileRequest, _callback);
        }
    }

    /**
     * Parse a CSV file in preparation for column matching as part of spreadsheet import process
     * 
     * @param orgId Org identifier (either id or slug) (required)
     * @return CsvDataColumnMatchRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
     </table>
     */
    public CsvDataColumnMatchRequestBuilder csvDataColumnMatch(String orgId) throws IllegalArgumentException {
        if (orgId == null) throw new IllegalArgumentException("\"orgId\" is required but got null");
            

        return new CsvDataColumnMatchRequestBuilder(orgId);
    }
    private okhttp3.Call csvDataWithColumnMatchCall(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, Boolean syncImages, File _file, Object userDefinedFieldAliases, ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importCsvDataWithColumnMatchRequest;

        // create path and map variables
        String localVarPath = "/v1/org/{orgId}/import/csv/columnMatch"
            .replace("{" + "orgId" + "}", localVarApiClient.escapeString(orgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (userDefinedFieldAliases != null) {
            localVarFormParams.put("userDefinedFieldAliases", userDefinedFieldAliases);
        }

        if (scenarioId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scenarioId", scenarioId));
        }

        if (skipErrors != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipErrors", skipErrors));
        }

        if (upsert != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("upsert", upsert));
        }

        if (createGroups != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("createGroups", createGroups));
        }

        if (disableSyncHireDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("disableSyncHireDate", disableSyncHireDate));
        }

        if (updateTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updateTypes", updateTypes));
        }

        if (notifyUserIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyUserIds", notifyUserIds));
        }

        if (notifyAppName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyAppName", notifyAppName));
        }

        if (defaultChangeDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("defaultChangeDate", defaultChangeDate));
        }

        if (disableOverwritePerson != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("disableOverwritePerson", disableOverwritePerson));
        }

        if (importDryRun != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importDryRun", importDryRun));
        }

        if (importAfterDryRun != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importAfterDryRun", importAfterDryRun));
        }

        if (parentProcessId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentProcessId", parentProcessId));
        }

        if (importSource != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importSource", importSource));
        }

        if (syncImages != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("syncImages", syncImages));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call csvDataWithColumnMatchValidateBeforeCall(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, Boolean syncImages, File _file, Object userDefinedFieldAliases, ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orgId' is set
        if (orgId == null) {
            throw new ApiException("Missing the required parameter 'orgId' when calling csvDataWithColumnMatch(Async)");
        }

        return csvDataWithColumnMatchCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, syncImages, _file, userDefinedFieldAliases, importCsvDataWithColumnMatchRequest, _callback);

    }


    private ApiResponse<Process> csvDataWithColumnMatchWithHttpInfo(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, Boolean syncImages, File _file, Object userDefinedFieldAliases, ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest) throws ApiException {
        okhttp3.Call localVarCall = csvDataWithColumnMatchValidateBeforeCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, syncImages, _file, userDefinedFieldAliases, importCsvDataWithColumnMatchRequest, null);
        Type localVarReturnType = new TypeToken<Process>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call csvDataWithColumnMatchAsync(String orgId, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, Boolean syncImages, File _file, Object userDefinedFieldAliases, ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest, final ApiCallback<Process> _callback) throws ApiException {

        okhttp3.Call localVarCall = csvDataWithColumnMatchValidateBeforeCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, syncImages, _file, userDefinedFieldAliases, importCsvDataWithColumnMatchRequest, _callback);
        Type localVarReturnType = new TypeToken<Process>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CsvDataWithColumnMatchRequestBuilder {
        private final String orgId;
        private String scenarioId;
        private Boolean skipErrors;
        private Boolean upsert;
        private Boolean createGroups;
        private Boolean disableSyncHireDate;
        private String updateTypes;
        private String notifyUserIds;
        private String notifyAppName;
        private LocalDate defaultChangeDate;
        private Boolean disableOverwritePerson;
        private Boolean importDryRun;
        private Boolean importAfterDryRun;
        private String parentProcessId;
        private String importSource;
        private Boolean syncImages;
        private File _file;
        private Object userDefinedFieldAliases;

        private CsvDataWithColumnMatchRequestBuilder(String orgId) {
            this.orgId = orgId;
        }

        /**
         * Set scenarioId
         * @param scenarioId scenario id to import into (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder scenarioId(String scenarioId) {
            this.scenarioId = scenarioId;
            return this;
        }
        
        /**
         * Set skipErrors
         * @param skipErrors whether to skip erroneous rows, or reject the entire upload if any are invalid (default) (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder skipErrors(Boolean skipErrors) {
            this.skipErrors = skipErrors;
            return this;
        }
        
        /**
         * Set upsert
         * @param upsert whether to create persons/jobs that are not matched (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder upsert(Boolean upsert) {
            this.upsert = upsert;
            return this;
        }
        
        /**
         * Set createGroups
         * @param createGroups whether to create groups that are not matched (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder createGroups(Boolean createGroups) {
            this.createGroups = createGroups;
            return this;
        }
        
        /**
         * Set disableSyncHireDate
         * @param disableSyncHireDate whether to disable adjusting dates of hires in cases where the start dates differ (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder disableSyncHireDate(Boolean disableSyncHireDate) {
            this.disableSyncHireDate = disableSyncHireDate;
            return this;
        }
        
        /**
         * Set updateTypes
         * @param updateTypes types of updates to apply (default all: title,comp,group,relationship,data,other) (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder updateTypes(String updateTypes) {
            this.updateTypes = updateTypes;
            return this;
        }
        
        /**
         * Set notifyUserIds
         * @param notifyUserIds comma-separated list of user ids who should be notified when the import is complete (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder notifyUserIds(String notifyUserIds) {
            this.notifyUserIds = notifyUserIds;
            return this;
        }
        
        /**
         * Set notifyAppName
         * @param notifyAppName name of the app that should be listed in the notify (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder notifyAppName(String notifyAppName) {
            this.notifyAppName = notifyAppName;
            return this;
        }
        
        /**
         * Set defaultChangeDate
         * @param defaultChangeDate date of the changes - if not presented on the csv file (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder defaultChangeDate(LocalDate defaultChangeDate) {
            this.defaultChangeDate = defaultChangeDate;
            return this;
        }
        
        /**
         * Set disableOverwritePerson
         * @param disableOverwritePerson disable overwriting changes to persons&#39; data -- only update data if the person field is null (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder disableOverwritePerson(Boolean disableOverwritePerson) {
            this.disableOverwritePerson = disableOverwritePerson;
            return this;
        }
        
        /**
         * Set importDryRun
         * @param importDryRun import dry run (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder importDryRun(Boolean importDryRun) {
            this.importDryRun = importDryRun;
            return this;
        }
        
        /**
         * Set importAfterDryRun
         * @param importAfterDryRun whether to automatically import if dry run succeeds (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder importAfterDryRun(Boolean importAfterDryRun) {
            this.importAfterDryRun = importAfterDryRun;
            return this;
        }
        
        /**
         * Set parentProcessId
         * @param parentProcessId process id of parent process (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder parentProcessId(String parentProcessId) {
            this.parentProcessId = parentProcessId;
            return this;
        }
        
        /**
         * Set importSource
         * @param importSource self identified source caller into this method (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder importSource(String importSource) {
            this.importSource = importSource;
            return this;
        }
        
        /**
         * Set syncImages
         * @param syncImages import images from csv (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder syncImages(Boolean syncImages) {
            this.syncImages = syncImages;
            return this;
        }
        
        /**
         * Set _file
         * @param _file  (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder _file(File _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set userDefinedFieldAliases
         * @param userDefinedFieldAliases user defined field aliases for column matching (optional)
         * @return CsvDataWithColumnMatchRequestBuilder
         */
        public CsvDataWithColumnMatchRequestBuilder userDefinedFieldAliases(Object userDefinedFieldAliases) {
            this.userDefinedFieldAliases = userDefinedFieldAliases;
            return this;
        }
        
        /**
         * Build call for csvDataWithColumnMatch
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest = buildBodyParams();
            return csvDataWithColumnMatchCall(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, syncImages, _file, userDefinedFieldAliases, importCsvDataWithColumnMatchRequest, _callback);
        }

        private ImportCsvDataWithColumnMatchRequest buildBodyParams() {
            ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest = new ImportCsvDataWithColumnMatchRequest();
            importCsvDataWithColumnMatchRequest._file(this._file);
            importCsvDataWithColumnMatchRequest.userDefinedFieldAliases(this.userDefinedFieldAliases);
            return importCsvDataWithColumnMatchRequest;
        }

        /**
         * Execute csvDataWithColumnMatch request
         * @return Process
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public Process execute() throws ApiException {
            ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest = buildBodyParams();
            ApiResponse<Process> localVarResp = csvDataWithColumnMatchWithHttpInfo(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, syncImages, _file, userDefinedFieldAliases, importCsvDataWithColumnMatchRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute csvDataWithColumnMatch request with HTTP info returned
         * @return ApiResponse&lt;Process&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Process> executeWithHttpInfo() throws ApiException {
            ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest = buildBodyParams();
            return csvDataWithColumnMatchWithHttpInfo(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, syncImages, _file, userDefinedFieldAliases, importCsvDataWithColumnMatchRequest);
        }

        /**
         * Execute csvDataWithColumnMatch request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Process> _callback) throws ApiException {
            ImportCsvDataWithColumnMatchRequest importCsvDataWithColumnMatchRequest = buildBodyParams();
            return csvDataWithColumnMatchAsync(orgId, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, syncImages, _file, userDefinedFieldAliases, importCsvDataWithColumnMatchRequest, _callback);
        }
    }

    /**
     * Import data from CSV file
     * 
     * @param orgId Org identifier (either id or slug) (required)
     * @return CsvDataWithColumnMatchRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
     </table>
     */
    public CsvDataWithColumnMatchRequestBuilder csvDataWithColumnMatch(String orgId) throws IllegalArgumentException {
        if (orgId == null) throw new IllegalArgumentException("\"orgId\" is required but got null");
            

        return new CsvDataWithColumnMatchRequestBuilder(orgId);
    }
    private okhttp3.Call csvDataWithFilePathCall(String orgId, String filePath, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/org/{orgId}/import/csv/filepath"
            .replace("{" + "orgId" + "}", localVarApiClient.escapeString(orgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filePath != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filePath", filePath));
        }

        if (scenarioId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scenarioId", scenarioId));
        }

        if (skipErrors != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipErrors", skipErrors));
        }

        if (upsert != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("upsert", upsert));
        }

        if (createGroups != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("createGroups", createGroups));
        }

        if (disableSyncHireDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("disableSyncHireDate", disableSyncHireDate));
        }

        if (updateTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updateTypes", updateTypes));
        }

        if (notifyUserIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyUserIds", notifyUserIds));
        }

        if (notifyAppName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyAppName", notifyAppName));
        }

        if (defaultChangeDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("defaultChangeDate", defaultChangeDate));
        }

        if (disableOverwritePerson != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("disableOverwritePerson", disableOverwritePerson));
        }

        if (importDryRun != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importDryRun", importDryRun));
        }

        if (importAfterDryRun != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importAfterDryRun", importAfterDryRun));
        }

        if (parentProcessId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentProcessId", parentProcessId));
        }

        if (importSource != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importSource", importSource));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call csvDataWithFilePathValidateBeforeCall(String orgId, String filePath, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orgId' is set
        if (orgId == null) {
            throw new ApiException("Missing the required parameter 'orgId' when calling csvDataWithFilePath(Async)");
        }

        return csvDataWithFilePathCall(orgId, filePath, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, _callback);

    }


    private ApiResponse<Process> csvDataWithFilePathWithHttpInfo(String orgId, String filePath, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource) throws ApiException {
        okhttp3.Call localVarCall = csvDataWithFilePathValidateBeforeCall(orgId, filePath, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, null);
        Type localVarReturnType = new TypeToken<Process>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call csvDataWithFilePathAsync(String orgId, String filePath, String scenarioId, Boolean skipErrors, Boolean upsert, Boolean createGroups, Boolean disableSyncHireDate, String updateTypes, String notifyUserIds, String notifyAppName, LocalDate defaultChangeDate, Boolean disableOverwritePerson, Boolean importDryRun, Boolean importAfterDryRun, String parentProcessId, String importSource, final ApiCallback<Process> _callback) throws ApiException {

        okhttp3.Call localVarCall = csvDataWithFilePathValidateBeforeCall(orgId, filePath, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, _callback);
        Type localVarReturnType = new TypeToken<Process>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CsvDataWithFilePathRequestBuilder {
        private final String orgId;
        private String filePath;
        private String scenarioId;
        private Boolean skipErrors;
        private Boolean upsert;
        private Boolean createGroups;
        private Boolean disableSyncHireDate;
        private String updateTypes;
        private String notifyUserIds;
        private String notifyAppName;
        private LocalDate defaultChangeDate;
        private Boolean disableOverwritePerson;
        private Boolean importDryRun;
        private Boolean importAfterDryRun;
        private String parentProcessId;
        private String importSource;

        private CsvDataWithFilePathRequestBuilder(String orgId) {
            this.orgId = orgId;
        }

        /**
         * Set filePath
         * @param filePath filePath (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder filePath(String filePath) {
            this.filePath = filePath;
            return this;
        }
        
        /**
         * Set scenarioId
         * @param scenarioId scenario id to import into (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder scenarioId(String scenarioId) {
            this.scenarioId = scenarioId;
            return this;
        }
        
        /**
         * Set skipErrors
         * @param skipErrors whether to skip erroneous rows, or reject the entire upload if any are invalid (default) (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder skipErrors(Boolean skipErrors) {
            this.skipErrors = skipErrors;
            return this;
        }
        
        /**
         * Set upsert
         * @param upsert whether to create persons/jobs that are not matched (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder upsert(Boolean upsert) {
            this.upsert = upsert;
            return this;
        }
        
        /**
         * Set createGroups
         * @param createGroups whether to create groups that are not matched (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder createGroups(Boolean createGroups) {
            this.createGroups = createGroups;
            return this;
        }
        
        /**
         * Set disableSyncHireDate
         * @param disableSyncHireDate whether to disable adjusting dates of hires in cases where the start dates differ (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder disableSyncHireDate(Boolean disableSyncHireDate) {
            this.disableSyncHireDate = disableSyncHireDate;
            return this;
        }
        
        /**
         * Set updateTypes
         * @param updateTypes types of updates to apply (default all: title,comp,group,relationship,data,other) (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder updateTypes(String updateTypes) {
            this.updateTypes = updateTypes;
            return this;
        }
        
        /**
         * Set notifyUserIds
         * @param notifyUserIds comma-separated list of user ids who should be notified when the import is complete (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder notifyUserIds(String notifyUserIds) {
            this.notifyUserIds = notifyUserIds;
            return this;
        }
        
        /**
         * Set notifyAppName
         * @param notifyAppName name of the app that should be listed in the notify (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder notifyAppName(String notifyAppName) {
            this.notifyAppName = notifyAppName;
            return this;
        }
        
        /**
         * Set defaultChangeDate
         * @param defaultChangeDate date of the changes - if not presented on the csv file (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder defaultChangeDate(LocalDate defaultChangeDate) {
            this.defaultChangeDate = defaultChangeDate;
            return this;
        }
        
        /**
         * Set disableOverwritePerson
         * @param disableOverwritePerson disable overwriting changes to persons&#39; data -- only update data if the person field is null (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder disableOverwritePerson(Boolean disableOverwritePerson) {
            this.disableOverwritePerson = disableOverwritePerson;
            return this;
        }
        
        /**
         * Set importDryRun
         * @param importDryRun import dry run (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder importDryRun(Boolean importDryRun) {
            this.importDryRun = importDryRun;
            return this;
        }
        
        /**
         * Set importAfterDryRun
         * @param importAfterDryRun whether to automatically import if dry run succeeds (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder importAfterDryRun(Boolean importAfterDryRun) {
            this.importAfterDryRun = importAfterDryRun;
            return this;
        }
        
        /**
         * Set parentProcessId
         * @param parentProcessId process id of parent process (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder parentProcessId(String parentProcessId) {
            this.parentProcessId = parentProcessId;
            return this;
        }
        
        /**
         * Set importSource
         * @param importSource self identified source caller into this method (optional)
         * @return CsvDataWithFilePathRequestBuilder
         */
        public CsvDataWithFilePathRequestBuilder importSource(String importSource) {
            this.importSource = importSource;
            return this;
        }
        
        /**
         * Build call for csvDataWithFilePath
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return csvDataWithFilePathCall(orgId, filePath, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, _callback);
        }


        /**
         * Execute csvDataWithFilePath request
         * @return Process
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public Process execute() throws ApiException {
            ApiResponse<Process> localVarResp = csvDataWithFilePathWithHttpInfo(orgId, filePath, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute csvDataWithFilePath request with HTTP info returned
         * @return ApiResponse&lt;Process&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Process> executeWithHttpInfo() throws ApiException {
            return csvDataWithFilePathWithHttpInfo(orgId, filePath, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource);
        }

        /**
         * Execute csvDataWithFilePath request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Process> _callback) throws ApiException {
            return csvDataWithFilePathAsync(orgId, filePath, scenarioId, skipErrors, upsert, createGroups, disableSyncHireDate, updateTypes, notifyUserIds, notifyAppName, defaultChangeDate, disableOverwritePerson, importDryRun, importAfterDryRun, parentProcessId, importSource, _callback);
        }
    }

    /**
     * Import data from CSV file
     * 
     * @param orgId Org identifier (either id or slug) (required)
     * @return CsvDataWithFilePathRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> invalid manifest data </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> not authorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> permission denied </td><td>  -  </td></tr>
     </table>
     */
    public CsvDataWithFilePathRequestBuilder csvDataWithFilePath(String orgId) throws IllegalArgumentException {
        if (orgId == null) throw new IllegalArgumentException("\"orgId\" is required but got null");
            

        return new CsvDataWithFilePathRequestBuilder(orgId);
    }
    private okhttp3.Call spreadsheetValidationCall(String orgId, Integer maxRows, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fileUploadNewFileRequest;

        // create path and map variables
        String localVarPath = "/v1/org/{orgId}/import/spreadsheet/validateFormat"
            .replace("{" + "orgId" + "}", localVarApiClient.escapeString(orgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRows != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRows", maxRows));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call spreadsheetValidationValidateBeforeCall(String orgId, Integer maxRows, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orgId' is set
        if (orgId == null) {
            throw new ApiException("Missing the required parameter 'orgId' when calling spreadsheetValidation(Async)");
        }

        return spreadsheetValidationCall(orgId, maxRows, fileUploadNewFileRequest, _callback);

    }


    private ApiResponse<Void> spreadsheetValidationWithHttpInfo(String orgId, Integer maxRows, FileUploadNewFileRequest fileUploadNewFileRequest) throws ApiException {
        okhttp3.Call localVarCall = spreadsheetValidationValidateBeforeCall(orgId, maxRows, fileUploadNewFileRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call spreadsheetValidationAsync(String orgId, Integer maxRows, FileUploadNewFileRequest fileUploadNewFileRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = spreadsheetValidationValidateBeforeCall(orgId, maxRows, fileUploadNewFileRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class SpreadsheetValidationRequestBuilder {
        private final String orgId;
        private File _file;
        private Integer maxRows;

        private SpreadsheetValidationRequestBuilder(String orgId) {
            this.orgId = orgId;
        }

        /**
         * Set _file
         * @param _file  (optional)
         * @return SpreadsheetValidationRequestBuilder
         */
        public SpreadsheetValidationRequestBuilder _file(File _file) {
            this._file = _file;
            return this;
        }
        
        /**
         * Set maxRows
         * @param maxRows Max rows allowed in an imported spreadsheet file (optional)
         * @return SpreadsheetValidationRequestBuilder
         */
        public SpreadsheetValidationRequestBuilder maxRows(Integer maxRows) {
            this.maxRows = maxRows;
            return this;
        }
        
        /**
         * Build call for spreadsheetValidation
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return spreadsheetValidationCall(orgId, maxRows, fileUploadNewFileRequest, _callback);
        }

        private FileUploadNewFileRequest buildBodyParams() {
            FileUploadNewFileRequest fileUploadNewFileRequest = new FileUploadNewFileRequest();
            fileUploadNewFileRequest._file(this._file);
            return fileUploadNewFileRequest;
        }

        /**
         * Execute spreadsheetValidation request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            spreadsheetValidationWithHttpInfo(orgId, maxRows, fileUploadNewFileRequest);
        }

        /**
         * Execute spreadsheetValidation request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return spreadsheetValidationWithHttpInfo(orgId, maxRows, fileUploadNewFileRequest);
        }

        /**
         * Execute spreadsheetValidation request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            FileUploadNewFileRequest fileUploadNewFileRequest = buildBodyParams();
            return spreadsheetValidationAsync(orgId, maxRows, fileUploadNewFileRequest, _callback);
        }
    }

    /**
     * Check if a spreadsheet file is valid to be imported
     * 
     * @param orgId Org identifier (either id or slug) (required)
     * @return SpreadsheetValidationRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> not found </td><td>  -  </td></tr>
     </table>
     */
    public SpreadsheetValidationRequestBuilder spreadsheetValidation(String orgId) throws IllegalArgumentException {
        if (orgId == null) throw new IllegalArgumentException("\"orgId\" is required but got null");
            

        return new SpreadsheetValidationRequestBuilder(orgId);
    }
}
